>我一直以为质数很简单，直到我在笔试的时候翻了车  
># 论一个程序员的基本修养  

# 1.什么是质数~~(没人不知道)~~  
质数的定义极其简单：如果一个树只能被1和它自己整出，那么这个数就是质数。  
道理我都懂，但是就像新闻一样，篇幅越短，事情越大。  
看看质数的定义，现在考虑一下如果让你数一下10k以内的质数，咋办？
  
# 2.计数思路  
其实仔细想一下，统计一个范围内的质数，归根结底还是要靠数(三声)。但是就这么一个事情里面也有很多技巧和思想。
从头说，最简单的实现思路：  
*从头开始一个一个判断是否可以被1和自身之外的数整除*  
代码大概长这样：  
```python  

def isPrime(n):
    for i in range(2,n):
        if not n%i :
            return False
    return True    

count = 0
for i in range(2,100):
    if isPrime(i):
        count += 1

print(count)
```  
从形式上看这个解法确实严格遵循上面所提到的思路，但是直觉告诉我里面一定有什么不对的地方。  
回想一下小学时学的乘法口诀：  
```python  

2*3=6       3*2=6       4*2=8       ...
2*4=8       3*3=9       4*3=12      ...
2*5=10      3*4=12      4*4=16      ...
...         ...         ...         ...
```  
仅仅在上面写出的9组乘法中就有3个结果(6,8,12)出现了重复，那么现在的问题是：  
*如何规避掉`2*3`和`3*2`这种重复计算*   
参考上面的定义，可以得到一条很有用的性质：  
*大于1的任意两数相乘结果一定不为质数*  
根据以上性质，现在以`12`这个数为例，乘法构成有以下几种组合：  
```python  

```  
不难发现重复组合出现的位置在`3*4`和`4*3`中间，那么思路就很清晰了：  
*让`*`两侧的数都等于一个`>3`并且`<4`的数*  
这个数就是`sqrt(12)`，所以我们对于每个数只需要遍历`range(2,sqrt(n))`就可以遍历到所有的组合了。  
对上面的基本实现进行优化：
```python  

n = 100  # 计数区间
isPrime = [True for i in range(n)]  # 初始化计数列表

p1 = 2
while p1**2 < n:    # 遍历到sqrt(n)停止
    p2 = 2
    while p2*p1 < n:    # 在n区间内的所有乘法结果都不为质数
        isPrime[p2*p1] = False
        p2 += 1
    p1 += 1

print(isPrime.count(True)-2)
```  

# 3.去除冗余计算  
上面优化到`sqrt(n)`已经去除了一半冗余计算，但是直觉告诉我们这个流程内部还存在大量的冗余。  
下面继续思考如下计算：  
```python  
12 = 2 * 6
12 = 3 * 4
12 = sqrt(12) * sqrt(12)
12 = 4 * 3
12 = 6 * 2
```  
我们已经知道只需要遍历到`sqrt(n)`之前就可以找到所有的组合，但是从上面的列表中可以看出，剩下一半的组合中仍然存在冗余：
当我们遍历到`3*4`的时候，其结果`12`早已被`2*6`标记为`False`了。
按照上述逻辑，`p1`减少到了`range(2,sqrt(n))`，但`p2`仍然是`range(2,n)`，也就是说到目前为止`p1*p2`得到的结果仍然可能是冗余的。  
根据上面分析的乘法的对称性，我们也可以同时对`p2`的范围进行优化：  
```python  

n = 100     # 计数区间
isPrime = [True for i in range(n)]      # 初始化计数列表

p1 = 2
while p1**2 < n:        # p1从sqrt(n)开始
    p2 = p1**2         # p2从sqrt(n)开始
    while p2 < n:
        isPrime[p2] = False     
        p2 += p1    
    p1 += 1
print(isPrime.count(True)-2)
```  
上述内层循环的优化不太容易想通的地方应该就是这一句`p2 += p1`  
内层循环每次并不是增加`1`而是增加`p1`，为了理解这个操作，我们来找一找规律：  
```python

p1 = 3
p2 = 9      # p2 = p1**2 
p1 * p2 = 27

p1 = 2
p2 = 15
p1 * p2 = 30

p1 = 3
p2 = 10     # p2 += 1
p1 * p2 = 30
```  
这养问题就显而易见了：  
*当`p2 += 1`的时候，`3*10`的结果已经被`2*15`标记为`False`了*  
于是让`p2`每次增加`p1`就成为了规避重复的一种方法。

